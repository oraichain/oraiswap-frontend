/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.20.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import {Addr, Uint128, Binary, AssetInfo, Decimal, Cw20ReceiveMsg, Asset, RewardInfoResponseItem} from "./types";
import {InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg, ConfigResponse, PoolInfoResponse, RewardInfoResponse, ArrayOfRewardInfoResponse, RewardsPerSecResponse} from "./OraiswapStaking.types";
export interface OraiswapStakingReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  poolInfo: ({
    assetInfo
  }: {
    assetInfo: AssetInfo;
  }) => Promise<PoolInfoResponse>;
  rewardsPerSec: ({
    assetInfo
  }: {
    assetInfo: AssetInfo;
  }) => Promise<RewardsPerSecResponse>;
  rewardInfo: ({
    assetInfo,
    stakerAddr
  }: {
    assetInfo?: AssetInfo;
    stakerAddr: Addr;
  }) => Promise<RewardInfoResponse>;
  rewardInfos: ({
    assetInfo,
    limit,
    order,
    startAfter
  }: {
    assetInfo: AssetInfo;
    limit?: number;
    order?: number;
    startAfter?: Addr;
  }) => Promise<ArrayOfRewardInfoResponse>;
}
export class OraiswapStakingQueryClient implements OraiswapStakingReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.poolInfo = this.poolInfo.bind(this);
    this.rewardsPerSec = this.rewardsPerSec.bind(this);
    this.rewardInfo = this.rewardInfo.bind(this);
    this.rewardInfos = this.rewardInfos.bind(this);
  }

  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  poolInfo = async ({
    assetInfo
  }: {
    assetInfo: AssetInfo;
  }): Promise<PoolInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pool_info: {
        asset_info: assetInfo
      }
    });
  };
  rewardsPerSec = async ({
    assetInfo
  }: {
    assetInfo: AssetInfo;
  }): Promise<RewardsPerSecResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      rewards_per_sec: {
        asset_info: assetInfo
      }
    });
  };
  rewardInfo = async ({
    assetInfo,
    stakerAddr
  }: {
    assetInfo?: AssetInfo;
    stakerAddr: Addr;
  }): Promise<RewardInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reward_info: {
        asset_info: assetInfo,
        staker_addr: stakerAddr
      }
    });
  };
  rewardInfos = async ({
    assetInfo,
    limit,
    order,
    startAfter
  }: {
    assetInfo: AssetInfo;
    limit?: number;
    order?: number;
    startAfter?: Addr;
  }): Promise<ArrayOfRewardInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reward_infos: {
        asset_info: assetInfo,
        limit,
        order,
        start_after: startAfter
      }
    });
  };
}
export interface OraiswapStakingInterface extends OraiswapStakingReadOnlyInterface {
  contractAddress: string;
  sender: string;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    owner,
    rewarder
  }: {
    owner?: Addr;
    rewarder?: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  registerAsset: ({
    assetInfo,
    stakingToken
  }: {
    assetInfo: AssetInfo;
    stakingToken: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  deprecateStakingToken: ({
    assetInfo,
    newStakingToken
  }: {
    assetInfo: AssetInfo;
    newStakingToken: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  updateRewardsPerSec: ({
    assetInfo,
    assets
  }: {
    assetInfo: AssetInfo;
    assets: Asset[];
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  depositReward: ({
    rewards
  }: {
    rewards: Asset[];
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  unbond: ({
    amount,
    assetInfo
  }: {
    amount: Uint128;
    assetInfo: AssetInfo;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    assetInfo
  }: {
    assetInfo?: AssetInfo;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawOthers: ({
    assetInfo,
    stakerAddrs
  }: {
    assetInfo?: AssetInfo;
    stakerAddrs: Addr[];
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  autoStake: ({
    assets,
    slippageTolerance
  }: {
    assets: Asset[];
    slippageTolerance?: Decimal;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  autoStakeHook: ({
    assetInfo,
    prevStakingTokenAmount,
    stakerAddr,
    stakingToken
  }: {
    assetInfo: AssetInfo;
    prevStakingTokenAmount: Uint128;
    stakerAddr: Addr;
    stakingToken: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  updateListStakers: ({
    assetInfo,
    stakers
  }: {
    assetInfo: AssetInfo;
    stakers: Addr[];
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
}
export class OraiswapStakingClient extends OraiswapStakingQueryClient implements OraiswapStakingInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.registerAsset = this.registerAsset.bind(this);
    this.deprecateStakingToken = this.deprecateStakingToken.bind(this);
    this.updateRewardsPerSec = this.updateRewardsPerSec.bind(this);
    this.depositReward = this.depositReward.bind(this);
    this.unbond = this.unbond.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.withdrawOthers = this.withdrawOthers.bind(this);
    this.autoStake = this.autoStake.bind(this);
    this.autoStakeHook = this.autoStakeHook.bind(this);
    this.updateListStakers = this.updateListStakers.bind(this);
  }

  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, $fee, $memo, $funds);
  };
  updateConfig = async ({
    owner,
    rewarder
  }: {
    owner?: Addr;
    rewarder?: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        owner,
        rewarder
      }
    }, $fee, $memo, $funds);
  };
  registerAsset = async ({
    assetInfo,
    stakingToken
  }: {
    assetInfo: AssetInfo;
    stakingToken: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_asset: {
        asset_info: assetInfo,
        staking_token: stakingToken
      }
    }, $fee, $memo, $funds);
  };
  deprecateStakingToken = async ({
    assetInfo,
    newStakingToken
  }: {
    assetInfo: AssetInfo;
    newStakingToken: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deprecate_staking_token: {
        asset_info: assetInfo,
        new_staking_token: newStakingToken
      }
    }, $fee, $memo, $funds);
  };
  updateRewardsPerSec = async ({
    assetInfo,
    assets
  }: {
    assetInfo: AssetInfo;
    assets: Asset[];
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_rewards_per_sec: {
        asset_info: assetInfo,
        assets
      }
    }, $fee, $memo, $funds);
  };
  depositReward = async ({
    rewards
  }: {
    rewards: Asset[];
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit_reward: {
        rewards
      }
    }, $fee, $memo, $funds);
  };
  unbond = async ({
    amount,
    assetInfo
  }: {
    amount: Uint128;
    assetInfo: AssetInfo;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond: {
        amount,
        asset_info: assetInfo
      }
    }, $fee, $memo, $funds);
  };
  withdraw = async ({
    assetInfo
  }: {
    assetInfo?: AssetInfo;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        asset_info: assetInfo
      }
    }, $fee, $memo, $funds);
  };
  withdrawOthers = async ({
    assetInfo,
    stakerAddrs
  }: {
    assetInfo?: AssetInfo;
    stakerAddrs: Addr[];
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_others: {
        asset_info: assetInfo,
        staker_addrs: stakerAddrs
      }
    }, $fee, $memo, $funds);
  };
  autoStake = async ({
    assets,
    slippageTolerance
  }: {
    assets: Asset[];
    slippageTolerance?: Decimal;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      auto_stake: {
        assets,
        slippage_tolerance: slippageTolerance
      }
    }, $fee, $memo, $funds);
  };
  autoStakeHook = async ({
    assetInfo,
    prevStakingTokenAmount,
    stakerAddr,
    stakingToken
  }: {
    assetInfo: AssetInfo;
    prevStakingTokenAmount: Uint128;
    stakerAddr: Addr;
    stakingToken: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      auto_stake_hook: {
        asset_info: assetInfo,
        prev_staking_token_amount: prevStakingTokenAmount,
        staker_addr: stakerAddr,
        staking_token: stakingToken
      }
    }, $fee, $memo, $funds);
  };
  updateListStakers = async ({
    assetInfo,
    stakers
  }: {
    assetInfo: AssetInfo;
    stakers: Addr[];
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_list_stakers: {
        asset_info: assetInfo,
        stakers
      }
    }, $fee, $memo, $funds);
  };
}