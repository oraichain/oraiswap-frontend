/**
 * This file was automatically generated by @oraichain/ts-codegen@0.35.9.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @oraichain/ts-codegen generate command to regenerate this file.
 */

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from '@cosmjs/cosmwasm-stargate'
import { Coin, StdFee } from '@cosmjs/amino'
import {
  Percentage,
  InstantiateMsg,
  ExecuteMsg,
  Addr,
  Liquidity,
  SqrtPrice,
  TokenAmount,
  PoolKey,
  FeeTier,
  SwapHop,
  QueryMsg,
  MigrateMsg,
  Boolean,
  ArrayOfFeeTier,
  ArrayOfLiquidityTick,
  LiquidityTick,
  Uint32,
  FeeGrowth,
  Pool,
  ArrayOfPoolWithPoolKey,
  PoolWithPoolKey,
  Position,
  ArrayOfPositionTick,
  PositionTick,
  ArrayOfPosition,
  QuoteResult,
  Tick,
  ArrayOfTupleOfUint16AndUint64
} from './OraiswapV3.types'
export interface OraiswapV3ReadOnlyInterface {
  contractAddress: string
  protocolFee: () => Promise<Percentage>
  position: ({ index, ownerId }: { index: number; ownerId: Addr }) => Promise<Position>
  positions: ({
    limit,
    offset,
    ownerId
  }: {
    limit?: number
    offset?: number
    ownerId: Addr
  }) => Promise<ArrayOfPosition>
  feeTierExist: ({ feeTier }: { feeTier: FeeTier }) => Promise<Boolean>
  pool: ({
    feeTier,
    token0,
    token1
  }: {
    feeTier: FeeTier
    token0: string
    token1: string
  }) => Promise<Pool>
  pools: ({
    limit,
    startAfter
  }: {
    limit?: number
    startAfter?: PoolKey
  }) => Promise<ArrayOfPoolWithPoolKey>
  tick: ({ index, key }: { index: number; key: PoolKey }) => Promise<Tick>
  isTickInitialized: ({ index, key }: { index: number; key: PoolKey }) => Promise<Boolean>
  feeTiers: () => Promise<ArrayOfFeeTier>
  positionTicks: ({
    offset,
    owner
  }: {
    offset: number
    owner: Addr
  }) => Promise<ArrayOfPositionTick>
  userPositionAmount: ({ owner }: { owner: Addr }) => Promise<Uint32>
  tickMap: ({
    lowerTickIndex,
    poolKey,
    upperTickIndex,
    xToY
  }: {
    lowerTickIndex: number
    poolKey: PoolKey
    upperTickIndex: number
    xToY: boolean
  }) => Promise<ArrayOfTupleOfUint16AndUint64>
  liquidityTicks: ({
    poolKey,
    tickIndexes
  }: {
    poolKey: PoolKey
    tickIndexes: number[]
  }) => Promise<ArrayOfLiquidityTick>
  liquidityTicksAmount: ({
    lowerTick,
    poolKey,
    upperTick
  }: {
    lowerTick: number
    poolKey: PoolKey
    upperTick: number
  }) => Promise<Uint32>
  poolsForPair: ({
    token0,
    token1
  }: {
    token0: string
    token1: string
  }) => Promise<ArrayOfPoolWithPoolKey>
  quote: ({
    amount,
    byAmountIn,
    poolKey,
    sqrtPriceLimit,
    xToY
  }: {
    amount: TokenAmount
    byAmountIn: boolean
    poolKey: PoolKey
    sqrtPriceLimit: SqrtPrice
    xToY: boolean
  }) => Promise<QuoteResult>
  quoteRoute: ({
    amountIn,
    swaps
  }: {
    amountIn: TokenAmount
    swaps: SwapHop[]
  }) => Promise<TokenAmount>
}
export class OraiswapV3QueryClient implements OraiswapV3ReadOnlyInterface {
  client: CosmWasmClient
  contractAddress: string

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client
    this.contractAddress = contractAddress
    this.protocolFee = this.protocolFee.bind(this)
    this.position = this.position.bind(this)
    this.positions = this.positions.bind(this)
    this.feeTierExist = this.feeTierExist.bind(this)
    this.pool = this.pool.bind(this)
    this.pools = this.pools.bind(this)
    this.tick = this.tick.bind(this)
    this.isTickInitialized = this.isTickInitialized.bind(this)
    this.feeTiers = this.feeTiers.bind(this)
    this.positionTicks = this.positionTicks.bind(this)
    this.userPositionAmount = this.userPositionAmount.bind(this)
    this.tickMap = this.tickMap.bind(this)
    this.liquidityTicks = this.liquidityTicks.bind(this)
    this.liquidityTicksAmount = this.liquidityTicksAmount.bind(this)
    this.poolsForPair = this.poolsForPair.bind(this)
    this.quote = this.quote.bind(this)
    this.quoteRoute = this.quoteRoute.bind(this)
  }

  protocolFee = async (): Promise<Percentage> => {
    return this.client.queryContractSmart(this.contractAddress, {
      protocol_fee: {}
    })
  }
  position = async ({ index, ownerId }: { index: number; ownerId: Addr }): Promise<Position> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position: {
        index,
        owner_id: ownerId
      }
    })
  }
  positions = async ({
    limit,
    offset,
    ownerId
  }: {
    limit?: number
    offset?: number
    ownerId: Addr
  }): Promise<ArrayOfPosition> => {
    return this.client.queryContractSmart(this.contractAddress, {
      positions: {
        limit,
        offset,
        owner_id: ownerId
      }
    })
  }
  feeTierExist = async ({ feeTier }: { feeTier: FeeTier }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee_tier_exist: {
        fee_tier: feeTier
      }
    })
  }
  pool = async ({
    feeTier,
    token0,
    token1
  }: {
    feeTier: FeeTier
    token0: string
    token1: string
  }): Promise<Pool> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pool: {
        fee_tier: feeTier,
        token_0: token0,
        token_1: token1
      }
    })
  }
  pools = async ({
    limit,
    startAfter
  }: {
    limit?: number
    startAfter?: PoolKey
  }): Promise<ArrayOfPoolWithPoolKey> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pools: {
        limit,
        start_after: startAfter
      }
    })
  }
  tick = async ({ index, key }: { index: number; key: PoolKey }): Promise<Tick> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tick: {
        index,
        key
      }
    })
  }
  isTickInitialized = async ({ index, key }: { index: number; key: PoolKey }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_tick_initialized: {
        index,
        key
      }
    })
  }
  feeTiers = async (): Promise<ArrayOfFeeTier> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee_tiers: {}
    })
  }
  positionTicks = async ({
    offset,
    owner
  }: {
    offset: number
    owner: Addr
  }): Promise<ArrayOfPositionTick> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position_ticks: {
        offset,
        owner
      }
    })
  }
  userPositionAmount = async ({ owner }: { owner: Addr }): Promise<Uint32> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_position_amount: {
        owner
      }
    })
  }
  tickMap = async ({
    lowerTickIndex,
    poolKey,
    upperTickIndex,
    xToY
  }: {
    lowerTickIndex: number
    poolKey: PoolKey
    upperTickIndex: number
    xToY: boolean
  }): Promise<ArrayOfTupleOfUint16AndUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tick_map: {
        lower_tick_index: lowerTickIndex,
        pool_key: poolKey,
        upper_tick_index: upperTickIndex,
        x_to_y: xToY
      }
    })
  }
  liquidityTicks = async ({
    poolKey,
    tickIndexes
  }: {
    poolKey: PoolKey
    tickIndexes: number[]
  }): Promise<ArrayOfLiquidityTick> => {
    return this.client.queryContractSmart(this.contractAddress, {
      liquidity_ticks: {
        pool_key: poolKey,
        tick_indexes: tickIndexes
      }
    })
  }
  liquidityTicksAmount = async ({
    lowerTick,
    poolKey,
    upperTick
  }: {
    lowerTick: number
    poolKey: PoolKey
    upperTick: number
  }): Promise<Uint32> => {
    return this.client.queryContractSmart(this.contractAddress, {
      liquidity_ticks_amount: {
        lower_tick: lowerTick,
        pool_key: poolKey,
        upper_tick: upperTick
      }
    })
  }
  poolsForPair = async ({
    token0,
    token1
  }: {
    token0: string
    token1: string
  }): Promise<ArrayOfPoolWithPoolKey> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pools_for_pair: {
        token_0: token0,
        token_1: token1
      }
    })
  }
  quote = async ({
    amount,
    byAmountIn,
    poolKey,
    sqrtPriceLimit,
    xToY
  }: {
    amount: TokenAmount
    byAmountIn: boolean
    poolKey: PoolKey
    sqrtPriceLimit: SqrtPrice
    xToY: boolean
  }): Promise<QuoteResult> => {
    return this.client.queryContractSmart(this.contractAddress, {
      quote: {
        amount,
        by_amount_in: byAmountIn,
        pool_key: poolKey,
        sqrt_price_limit: sqrtPriceLimit,
        x_to_y: xToY
      }
    })
  }
  quoteRoute = async ({
    amountIn,
    swaps
  }: {
    amountIn: TokenAmount
    swaps: SwapHop[]
  }): Promise<TokenAmount> => {
    return this.client.queryContractSmart(this.contractAddress, {
      quote_route: {
        amount_in: amountIn,
        swaps
      }
    })
  }
}
export interface OraiswapV3Interface extends OraiswapV3ReadOnlyInterface {
  contractAddress: string
  sender: string
  withdrawProtocolFee: (
    {
      poolKey
    }: {
      poolKey: PoolKey
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  changeProtocolFee: (
    {
      protocolFee
    }: {
      protocolFee: Percentage
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  changeFeeReceiver: (
    {
      feeReceiver,
      poolKey
    }: {
      feeReceiver: Addr
      poolKey: PoolKey
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  createPosition: (
    {
      liquidityDelta,
      lowerTick,
      poolKey,
      slippageLimitLower,
      slippageLimitUpper,
      upperTick
    }: {
      liquidityDelta: Liquidity
      lowerTick: number
      poolKey: PoolKey
      slippageLimitLower: SqrtPrice
      slippageLimitUpper: SqrtPrice
      upperTick: number
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  swap: (
    {
      amount,
      byAmountIn,
      poolKey,
      sqrtPriceLimit,
      xToY
    }: {
      amount: TokenAmount
      byAmountIn: boolean
      poolKey: PoolKey
      sqrtPriceLimit: SqrtPrice
      xToY: boolean
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  swapRoute: (
    {
      amountIn,
      expectedAmountOut,
      slippage,
      swaps
    }: {
      amountIn: TokenAmount
      expectedAmountOut: TokenAmount
      slippage: Percentage
      swaps: SwapHop[]
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  transferPosition: (
    {
      index,
      receiver
    }: {
      index: number
      receiver: string
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  claimFee: (
    {
      index
    }: {
      index: number
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  removePosition: (
    {
      index
    }: {
      index: number
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  createPool: (
    {
      feeTier,
      initSqrtPrice,
      initTick,
      token0,
      token1
    }: {
      feeTier: FeeTier
      initSqrtPrice: SqrtPrice
      initTick: number
      token0: string
      token1: string
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  addFeeTier: (
    {
      feeTier
    }: {
      feeTier: FeeTier
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  removeFeeTier: (
    {
      feeTier
    }: {
      feeTier: FeeTier
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
}
export class OraiswapV3Client extends OraiswapV3QueryClient implements OraiswapV3Interface {
  declare client: SigningCosmWasmClient
  sender: string
  declare contractAddress: string

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress)
    this.client = client
    this.sender = sender
    this.contractAddress = contractAddress
    this.withdrawProtocolFee = this.withdrawProtocolFee.bind(this)
    this.changeProtocolFee = this.changeProtocolFee.bind(this)
    this.changeFeeReceiver = this.changeFeeReceiver.bind(this)
    this.createPosition = this.createPosition.bind(this)
    this.swap = this.swap.bind(this)
    this.swapRoute = this.swapRoute.bind(this)
    this.transferPosition = this.transferPosition.bind(this)
    this.claimFee = this.claimFee.bind(this)
    this.removePosition = this.removePosition.bind(this)
    this.createPool = this.createPool.bind(this)
    this.addFeeTier = this.addFeeTier.bind(this)
    this.removeFeeTier = this.removeFeeTier.bind(this)
  }

  withdrawProtocolFee = async (
    {
      poolKey
    }: {
      poolKey: PoolKey
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        withdraw_protocol_fee: {
          pool_key: poolKey
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
  changeProtocolFee = async (
    {
      protocolFee
    }: {
      protocolFee: Percentage
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        change_protocol_fee: {
          protocol_fee: protocolFee
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
  changeFeeReceiver = async (
    {
      feeReceiver,
      poolKey
    }: {
      feeReceiver: Addr
      poolKey: PoolKey
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        change_fee_receiver: {
          fee_receiver: feeReceiver,
          pool_key: poolKey
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
  createPosition = async (
    {
      liquidityDelta,
      lowerTick,
      poolKey,
      slippageLimitLower,
      slippageLimitUpper,
      upperTick
    }: {
      liquidityDelta: Liquidity
      lowerTick: number
      poolKey: PoolKey
      slippageLimitLower: SqrtPrice
      slippageLimitUpper: SqrtPrice
      upperTick: number
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        create_position: {
          liquidity_delta: liquidityDelta,
          lower_tick: lowerTick,
          pool_key: poolKey,
          slippage_limit_lower: slippageLimitLower,
          slippage_limit_upper: slippageLimitUpper,
          upper_tick: upperTick
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
  swap = async (
    {
      amount,
      byAmountIn,
      poolKey,
      sqrtPriceLimit,
      xToY
    }: {
      amount: TokenAmount
      byAmountIn: boolean
      poolKey: PoolKey
      sqrtPriceLimit: SqrtPrice
      xToY: boolean
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        swap: {
          amount,
          by_amount_in: byAmountIn,
          pool_key: poolKey,
          sqrt_price_limit: sqrtPriceLimit,
          x_to_y: xToY
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
  swapRoute = async (
    {
      amountIn,
      expectedAmountOut,
      slippage,
      swaps
    }: {
      amountIn: TokenAmount
      expectedAmountOut: TokenAmount
      slippage: Percentage
      swaps: SwapHop[]
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        swap_route: {
          amount_in: amountIn,
          expected_amount_out: expectedAmountOut,
          slippage,
          swaps
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
  transferPosition = async (
    {
      index,
      receiver
    }: {
      index: number
      receiver: string
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        transfer_position: {
          index,
          receiver
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
  claimFee = async (
    {
      index
    }: {
      index: number
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_fee: {
          index
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
  removePosition = async (
    {
      index
    }: {
      index: number
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_position: {
          index
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
  createPool = async (
    {
      feeTier,
      initSqrtPrice,
      initTick,
      token0,
      token1
    }: {
      feeTier: FeeTier
      initSqrtPrice: SqrtPrice
      initTick: number
      token0: string
      token1: string
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        create_pool: {
          fee_tier: feeTier,
          init_sqrt_price: initSqrtPrice,
          init_tick: initTick,
          token_0: token0,
          token_1: token1
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
  addFeeTier = async (
    {
      feeTier
    }: {
      feeTier: FeeTier
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        add_fee_tier: {
          fee_tier: feeTier
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
  removeFeeTier = async (
    {
      feeTier
    }: {
      feeTier: FeeTier
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_fee_tier: {
          fee_tier: feeTier
        }
      },
      _fee,
      _memo,
      _funds
    )
  }
}
